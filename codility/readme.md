## Exercises
### Bitwise operations(bit-ops)
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | BinaryGap | Easy | O | 
2 | CountConformingBitmasks | Medium | O | O(log(A + B + C)). 문제에서 A, B, C 값의 범위를 제시하고 있는데, 최대 범위에 맞춰 bit 자릿수를 맞춰줘야한다.
3 | SparseBinaryDecomposition | Hard | O | O(log(N)) or O(1)

### Algorithmic skills
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | ArrListLen | Easy | O | 
2 | CountBoundedSlices | Medium | X | gg... performance 충족을 못하겠음. O(NlogN) or O(N)으로 설계해야함ㅜ
3 | TreeLongestZigZag | Medium | O | O(N)
4 | CountriesCount | Hard | O | O(N*M)

### Coding skills
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | ParkingBill | Elementary | O | 
2 | ParityDegree | Easy | O | 
3 | ThreeLetters | Medium | O | 

### Algorithmic skills
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | FirstUnique | Easy | O | O(N * log(N))
2 | StrSymmetryPoint | Easy | O(length(S)) | 
3 | TreeHeight | Easy | O | 
4 | ArrayInversionCount | Medium | O | O(NlogN). inversion count 문제는 무조건 merge sort로
5 | DisppearingPairs | Hard | O | O(N)
6 | PolygonConcavityIndex | Hard | X | gg

### 2015 Contest
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | LongestPassword | Easy | O | 
2 | FloodDepth | Midium | O | O(N)
3 | SlalomSkiing | Hard | X | pass...

### 2016 Contest
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | RectangleBuilderGreaterArea | Medium |  | 
2 | DwarfsRafting | Hard |  | 
3 | HilbertMaze | Hard |  | 
4 | TreeProduct | Hard |  | 

### 2017 Contest
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | TennisTournament | Elementary | O | 
2 | SocksLaundering | Midium | O | 
3 | ArrayRecovery | Hard |  | 
4 | DiamondsCount | Hard |  | 

## Lessons

### Lesson2: Arrays
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | CyclicRotation | Easy | O | 
2 | OddOccurrencesInArray | Easy | O | O(N) or O(N*log(N))

### Lesson3: Time Complexity
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | FrogJmp | Easy | O | O(1)
2 | PermMissingElem | Easy |  | 
3 | TapeEquilibrium | Easy | O | O(N)

### Lesson4: Counting Elements
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | FrogRiverOne | Easy |  | 
2 | PermCheck | Easy |  | 
3 | MaxCounters | Medium | O | O(N + M). 모든 연산자가 max_counter인 경우에 대한 예외처리만 잘 해주면 된다.
4 | MissingInteger | Medium | O | O(N) or O(NlogN)

### Lesson5: Prefix Sums
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | PassingCars | Easy |  | 
2 | CountDiv | Medium | O | O(1)
3 | GenomicRangeQuery | Medium | O | O(N + M)
4 | MinAvgTwoSlice | Medium | O | O(N)

### Lesson6: Sorting
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | Distinct | Easy | O | O(NlogN) or O(N)
2 | MaxProductOfThree | Easy |  | 
3 | Triangle | Easy |  | 
4 | NumberOfDiscIntersections | Medium | X | O(NlogN) or O(N).다른사람 풀이를 보고 겨우 이해...


### Lesson7: Stacks and Queues
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | Brackets | Easy |  | 
2 | Fish | Easy |  | 
3 | Nesting | Easy | O | O(N)
4 | StoneWall | Easy | X | O(N)

### Lesson8: Leader
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | Dominator | Easy |  | leader의 모든 index를 반환하는 문제. hash map 쓰면 될듯
2 | EquiLeader | Easy | O | O(N)

### Lesson9: Maximum slice problem
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | MaxProfit | Easy |  | 
2 | MaxSliceSum | Easy | X | O(N)
3 | MaxDoubleSliceSum | Medium | X | O(N)

### Lesson10: Prime and composite numbers
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | CountFactors | Easy |  | 
2 | MinPerimeterRectangle | Easy |  | 
3 | Flags | Medium | O | O(N)
4 | Peaks | Medium | X | 

### Lesson11: Sieve of Eratosthenes
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | CountNonDivisible | Medium | X | O(N**2)
2 | CountSemiprimes | Medium |  | 

### Lesson14: Binary search algorithm
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | MinMaxDivision | Medium | O | O(Nlog(N + M))
2 | NailingPlanks | Medium | X | gg

### Lesson16: Greedy Algorithms
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | MaxNonoverlappingSegments | Easy | O | O(N)
2 | TieRopes | Easy | O | O(N)

### Lesson17: Dynamic Programming
No | 문제 | 레벨 | 완료 | 비고
---|---|---|---|---
1 | NumberSolitaire | Medium | O | O(N)
2 | MinAbsSum | Hard | X | O(N^2 * max(abs(A)))